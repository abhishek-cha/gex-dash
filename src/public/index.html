<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>GEX Dash</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #0d1117;
      color: #c9d1d9;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;
      overflow: hidden;
      height: 100vh;
    }

    #login-screen {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      gap: 24px;
    }
    #login-screen h1 { font-size: 28px; color: #e6edf3; }
    #login-screen p { color: #8b949e; font-size: 14px; }
    #login-screen a {
      padding: 12px 32px;
      background: #238636;
      color: #fff;
      text-decoration: none;
      border-radius: 6px;
      font-size: 16px;
      font-weight: 600;
      transition: background 0.2s;
    }
    #login-screen a:hover { background: #2ea043; }

    #app { display: none; height: 100vh; flex-direction: column; }
    #app.active { display: flex; }

    #header {
      display: flex;
      align-items: center;
      gap: 16px;
      padding: 8px 16px;
      background: #161b22;
      border-bottom: 1px solid #21262d;
      flex-shrink: 0;
      height: 48px;
    }
    #header .symbol {
      font-size: 18px;
      font-weight: 700;
      color: #e6edf3;
    }
    #header .price {
      font-size: 16px;
      font-weight: 600;
      color: #e6edf3;
    }
    #header .change {
      font-size: 14px;
      font-weight: 600;
      padding: 2px 8px;
      border-radius: 4px;
    }
    #header .change.up { background: #238636; color: #fff; }
    #header .change.down { background: #da3633; color: #fff; }
    #header .search-box {
      margin-left: auto;
      display: flex;
      gap: 8px;
    }
    #header input {
      background: #0d1117;
      border: 1px solid #30363d;
      color: #c9d1d9;
      padding: 4px 12px;
      border-radius: 4px;
      font-size: 14px;
      width: 120px;
    }
    #header button {
      background: #21262d;
      color: #c9d1d9;
      border: 1px solid #30363d;
      padding: 4px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    #header button:hover { background: #30363d; }
    #header select {
      background: #0d1117;
      border: 1px solid #30363d;
      color: #c9d1d9;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 14px;
      cursor: pointer;
    }

    #chart-wrap {
      flex: 1;
      position: relative;
      overflow: hidden;
    }
    #chart-wrap canvas { display: block; }

    #chart-controls {
      position: absolute;
      top: 8px;
      right: calc(35% + 10px);
      z-index: 20;
      display: flex;
      gap: 6px;
    }
    #chart-controls select {
      background: #0d1117ee;
      border: 1px solid #30363d;
      color: #c9d1d9;
      padding: 3px 6px;
      border-radius: 4px;
      font-size: 12px;
      cursor: pointer;
    }

    #labels-overlay {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      pointer-events: none;
      overflow: hidden;
    }
    .price-label {
      position: absolute;
      font-size: 11px;
      color: #8b949e;
      white-space: nowrap;
    }
    .current-price-tag {
      position: absolute;
      font-size: 11px;
      font-weight: 700;
      color: #fff;
      background: #1f6feb;
      padding: 1px 6px;
      border-radius: 3px;
      white-space: nowrap;
    }
    .date-label {
      position: absolute;
      bottom: 2px;
      font-size: 10px;
      color: #484f58;
      white-space: nowrap;
    }
    .section-label {
      position: absolute;
      top: 4px;
      font-size: 10px;
      font-weight: 600;
      color: #484f58;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .gex-scale-label {
      position: absolute;
      bottom: 2px;
      font-size: 9px;
      color: #484f58;
      white-space: nowrap;
      transform: translateX(-50%);
    }
    .gex-loading-label {
      position: absolute;
      font-size: 12px;
      color: #484f58;
      white-space: nowrap;
      transform: translate(-50%, -50%);
    }

    #crosshair-h, #crosshair-v {
      position: absolute;
      background: rgba(139,148,158,0.3);
      pointer-events: none;
      display: none;
    }
    #crosshair-h { height: 1px; left: 0; right: 0; }
    #crosshair-v { width: 1px; top: 0; bottom: 0; }
    #tooltip {
      position: absolute;
      background: #1c2128;
      border: 1px solid #30363d;
      padding: 6px 10px;
      border-radius: 4px;
      font-size: 11px;
      color: #c9d1d9;
      pointer-events: none;
      display: none;
      white-space: nowrap;
      z-index: 10;
    }

    #loading {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      color: #8b949e;
      font-size: 14px;
    }

    #exp-filter-btn {
      background: #21262d;
      color: #c9d1d9;
      border: 1px solid #30363d;
      padding: 4px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      white-space: nowrap;
    }
    #exp-filter-btn:hover { background: #30363d; }
    #exp-filter-btn .badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background: #1f6feb;
      color: #fff;
      font-size: 11px;
      padding: 0 6px;
      border-radius: 8px;
      margin-left: 6px;
      min-width: 18px;
      height: 18px;
      line-height: 1;
    }

    #exp-dialog-backdrop {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.6);
      z-index: 100;
      align-items: center;
      justify-content: center;
    }
    #exp-dialog-backdrop.open { display: flex; }

    #exp-dialog {
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 8px;
      width: 340px;
      max-height: 70vh;
      display: flex;
      flex-direction: column;
      box-shadow: 0 8px 32px rgba(0,0,0,0.5);
    }
    #exp-dialog-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 16px;
      border-bottom: 1px solid #21262d;
    }
    #exp-dialog-header h3 {
      font-size: 14px;
      font-weight: 600;
      color: #e6edf3;
    }
    #exp-dialog-header .actions {
      display: flex;
      gap: 8px;
    }
    #exp-dialog-header button {
      background: none;
      border: none;
      color: #58a6ff;
      cursor: pointer;
      font-size: 12px;
      padding: 2px 4px;
    }
    #exp-dialog-header button:hover { text-decoration: underline; }
    #exp-dialog-close {
      color: #8b949e !important;
      font-size: 18px !important;
    }

    #exp-dialog-list {
      overflow-y: auto;
      padding: 8px 0;
      flex: 1;
    }
    #exp-dialog-list label {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 6px 16px;
      cursor: pointer;
      font-size: 13px;
      color: #c9d1d9;
      transition: background 0.15s;
    }
    #exp-dialog-list label:hover { background: #1c2128; }
    #exp-dialog-list input[type="checkbox"] {
      accent-color: #1f6feb;
      width: 15px;
      height: 15px;
      cursor: pointer;
    }

    #exp-dialog-footer {
      padding: 10px 16px;
      border-top: 1px solid #21262d;
      display: flex;
      justify-content: flex-end;
    }
    #exp-dialog-apply {
      background: #238636;
      color: #fff;
      border: none;
      padding: 6px 20px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
    }
    #exp-dialog-apply:hover { background: #2ea043; }
  </style>
</head>
<body>

<div id="login-screen">
  <h1>GEX Dash</h1>
  <p>Connect your Schwab Developer account to view Gamma Exposure levels</p>
  <a href="/auth/login">Connect with Schwab</a>
</div>

<div id="app">
  <div id="header">
    <span class="symbol" id="hdr-symbol">--</span>
    <span class="price" id="hdr-price">--</span>
    <span class="change" id="hdr-change">--</span>
    <select id="freq-select">
      <option value="5m">5 min</option>
      <option value="15m">15 min</option>
      <option value="30m">30 min</option>
      <option value="1D" selected>Daily</option>
      <option value="1W">Weekly</option>
      <option value="1M">Monthly</option>
    </select>
    <select id="range-select">
      <option value="5D">5D</option>
      <option value="1M">1M</option>
      <option value="3M">3M</option>
      <option value="6M">6M</option>
      <option value="YTD">YTD</option>
      <option value="1Y" selected>1Y</option>
      <option value="2Y">2Y</option>
      <option value="5Y">5Y</option>
      <option value="10Y">10Y</option>
      <option value="20Y">20Y</option>
    </select>
    <button id="exp-filter-btn">Expirations</button>
    <div class="search-box">
      <input type="text" id="symbol-input" placeholder="Symbol (e.g. AAPL)" />
      <button id="load-btn">Load</button>
    </div>
  </div>

  <div id="exp-dialog-backdrop">
    <div id="exp-dialog">
      <div id="exp-dialog-header">
        <h3>Filter Expirations</h3>
        <div class="actions">
          <button id="exp-select-all">Select All</button>
          <button id="exp-select-none">Clear</button>
          <button id="exp-dialog-close">&times;</button>
        </div>
      </div>
      <div id="exp-dialog-list"></div>
      <div id="exp-dialog-footer">
        <button id="exp-dialog-apply">Apply</button>
      </div>
    </div>
  </div>
  <div id="chart-wrap">
    <div id="loading">Loading chart data...</div>
    <div id="labels-overlay"></div>
    <div id="crosshair-h"></div>
    <div id="crosshair-v"></div>
    <div id="tooltip"></div>
  </div>
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.172.0/build/three.module.js"
  }
}
</script>

<script type="module">
import * as THREE from 'three';

const COLORS = {
  bg:           0x0d1117,
  grid:         0x1b2028,
  gridStrong:   0x21262d,
  candleUp:     0x26a69a,
  candleDown:   0xef5350,
  priceLine:    0x1f6feb,
  callGex:      0x4caf50,
  putGex:       0xf44336,
  netGex:       0x00bcd4,
  separator:    0x30363d,
};

const LAYOUT = {
  marginTop: 30,
  marginBottom: 30,
  marginLeft: 8,
  priceAxisWidth: 60,
  gexSectionRatio: 0.22,
  netGexSectionRatio: 0.13,
  candleGap: 0.3,
};

class GEXChart {
  constructor(container) {
    this.container = container;
    this.width = container.clientWidth;
    this.height = container.clientHeight;

    this.scene = new THREE.Scene();
    this.scene.background = new THREE.Color(COLORS.bg);

    this.camera = new THREE.OrthographicCamera(
      0, this.width, this.height, 0, -10, 10
    );
    this.camera.position.z = 1;

    this.renderer = new THREE.WebGLRenderer({ antialias: true });
    this.renderer.setPixelRatio(window.devicePixelRatio);
    this.renderer.setSize(this.width, this.height);
    container.insertBefore(this.renderer.domElement, container.firstChild);

    this.groups = {
      grid: new THREE.Group(),
      candles: new THREE.Group(),
      gexBars: new THREE.Group(),
      netGexBars: new THREE.Group(),
      overlays: new THREE.Group(),
    };
    for (const g of Object.values(this.groups)) this.scene.add(g);

    this.priceData = [];
    this.gexLevels = [];
    this.spotPrice = 0;

    this.viewPriceMin = 0;
    this.viewPriceMax = 0;
    this.viewStartIdx = 0;
    this.viewEndIdx = 0;

    this._setupInteraction();
    this._animate();

    window.addEventListener('resize', () => this._onResize());
  }

  _sectionBounds() {
    const w = this.width;
    const h = this.height;
    const netW = w * LAYOUT.netGexSectionRatio;
    const gexW = w * LAYOUT.gexSectionRatio;
    const axisW = LAYOUT.priceAxisWidth;
    const candleW = w - gexW - netW - axisW - LAYOUT.marginLeft;

    return {
      candle: { left: LAYOUT.marginLeft, right: LAYOUT.marginLeft + candleW, width: candleW },
      axis:   { left: LAYOUT.marginLeft + candleW, right: LAYOUT.marginLeft + candleW + axisW, width: axisW },
      gex:    { left: w - netW - gexW, right: w - netW, width: gexW },
      netGex: { left: w - netW, right: w, width: netW },
      top: h - LAYOUT.marginTop,
      bottom: LAYOUT.marginBottom,
      chartH: h - LAYOUT.marginTop - LAYOUT.marginBottom,
    };
  }

  _priceToY(price) {
    const s = this._sectionBounds();
    const t = (price - this.viewPriceMin) / (this.viewPriceMax - this.viewPriceMin);
    return s.bottom + t * s.chartH;
  }

  _yToPrice(y) {
    const s = this._sectionBounds();
    const t = (y - s.bottom) / s.chartH;
    return this.viewPriceMin + t * (this.viewPriceMax - this.viewPriceMin);
  }

  _idxToX(idx) {
    const s = this._sectionBounds();
    const visibleCount = this.viewEndIdx - this.viewStartIdx;
    if (visibleCount <= 0) return s.candle.left;
    const t = (idx - this.viewStartIdx) / visibleCount;
    return s.candle.left + t * s.candle.width;
  }

  loadPriceData(priceHistory) {
    this.priceData = priceHistory.candles.map(c => ({
      open: c.open,
      high: c.high,
      low: c.low,
      close: c.close,
      volume: c.volume,
      date: new Date(c.datetime),
    }));

    if (this.priceData.length > 0) {
      this.viewStartIdx = 0;
      this.viewEndIdx = this.priceData.length;
      this._autoFitY();
    }

    this.rebuild();
  }

  _autoFitY() {
    const start = Math.max(0, Math.floor(this.viewStartIdx));
    const end = Math.min(this.priceData.length, Math.ceil(this.viewEndIdx));
    if (start >= end) return;
    let lo = Infinity, hi = -Infinity;
    for (let i = start; i < end; i++) {
      const c = this.priceData[i];
      if (c.low < lo) lo = c.low;
      if (c.high > hi) hi = c.high;
    }
    if (lo === Infinity) return;
    const pad = (hi - lo) * 0.06 || 1;
    this.viewPriceMin = lo - pad;
    this.viewPriceMax = hi + pad;
  }

  loadGEXData(gexData) {
    this.gexLevels = gexData.gexLevels || [];
    this.spotPrice = gexData.underlyingPrice || gexData.underlying?.last || 0;
    this.rebuild();
  }

  clearGEX() {
    this.gexLevels = [];
    this.spotPrice = 0;
    this.rebuild();
  }

  rebuild() {
    for (const g of Object.values(this.groups)) {
      while (g.children.length) {
        const c = g.children[0];
        g.remove(c);
        if (c.geometry) c.geometry.dispose();
        if (c.material) c.material.dispose();
      }
    }
    this._buildGrid();
    this._buildCandles();
    this._buildGEXBars();
    this._buildNetGEXBars();
    this._buildSeparators();
    this._buildPriceLine();
    this._updateLabels();
    this._render();
  }

  _makePlane(x, y, w, h, color, opacity = 1.0) {
    const geo = new THREE.PlaneGeometry(w, h);
    const mat = new THREE.MeshBasicMaterial({
      color,
      transparent: opacity < 1,
      opacity,
    });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(x + w / 2, y + h / 2, 0);
    return mesh;
  }

  _makeLine(points, color, opacity = 1.0) {
    const geo = new THREE.BufferGeometry().setFromPoints(
      points.map(p => new THREE.Vector3(p[0], p[1], 0))
    );
    const mat = new THREE.LineBasicMaterial({
      color,
      transparent: opacity < 1,
      opacity,
    });
    return new THREE.Line(geo, mat);
  }

  _buildGrid() {
    const s = this._sectionBounds();
    const range = this.viewPriceMax - this.viewPriceMin;
    const step = this._niceStep(range, 10);
    const startP = Math.ceil(this.viewPriceMin / step) * step;

    for (let p = startP; p <= this.viewPriceMax; p += step) {
      const y = this._priceToY(p);
      this.groups.grid.add(
        this._makeLine(
          [[LAYOUT.marginLeft, y], [this.width, y]],
          COLORS.grid, 0.5
        )
      );
    }
  }

  _buildCandles() {
    const s = this._sectionBounds();
    const visibleCount = this.viewEndIdx - this.viewStartIdx;
    if (visibleCount <= 0) return;

    const candleW = (s.candle.width / visibleCount) * (1 - LAYOUT.candleGap);
    const wickW = Math.max(1, candleW * 0.1);

    const drawStart = Math.max(0, Math.floor(this.viewStartIdx));
    const drawEnd = Math.min(this.priceData.length, Math.ceil(this.viewEndIdx));
    for (let i = drawStart; i < drawEnd; i++) {
      const c = this.priceData[i];
      if (!c) continue;
      const x = this._idxToX(i + 0.5) - candleW / 2;
      const isUp = c.close >= c.open;
      const color = isUp ? COLORS.candleUp : COLORS.candleDown;

      const bodyLow = Math.min(c.open, c.close);
      const bodyHigh = Math.max(c.open, c.close);
      const yLow = this._priceToY(bodyLow);
      const yHigh = this._priceToY(bodyHigh);
      const bodyH = Math.max(yHigh - yLow, 1);
      this.groups.candles.add(this._makePlane(x, yLow, candleW, bodyH, color));

      const wickYLow = this._priceToY(c.low);
      const wickYHigh = this._priceToY(c.high);
      const wickX = this._idxToX(i + 0.5) - wickW / 2;
      this.groups.candles.add(
        this._makePlane(wickX, wickYLow, wickW, wickYHigh - wickYLow, color)
      );
    }
  }

  _buildGEXBars() {
    const s = this._sectionBounds();
    if (!this.gexLevels.length) return;

    const maxCallGex = Math.max(...this.gexLevels.map(l => Math.abs(l.callGex)), 1);
    const maxPutGex = Math.max(...this.gexLevels.map(l => Math.abs(l.putGex)), 1);
    const maxGex = Math.max(maxCallGex, maxPutGex);
    const halfW = s.gex.width / 2;
    const centerX = s.gex.left + halfW;

    const strikes = this.gexLevels.map(l => l.strike).sort((a, b) => a - b);

    for (const level of this.gexLevels) {
      const py = this._priceToY(level.strike);
      if (py < s.bottom || py > s.top) continue;
      const { y: barY, h: barH } = this._gexBarBounds(level.strike, strikes);

      if (level.callGex > 0) {
        const w = (level.callGex / maxGex) * halfW;
        this.groups.gexBars.add(
          this._makePlane(centerX, barY, w, barH, COLORS.callGex, 0.85)
        );
      }

      if (level.putGex < 0) {
        const w = (Math.abs(level.putGex) / maxGex) * halfW;
        this.groups.gexBars.add(
          this._makePlane(centerX - w, barY, w, barH, COLORS.putGex, 0.85)
        );
      }
    }
  }

  _buildNetGEXBars() {
    const s = this._sectionBounds();
    if (!this.gexLevels.length) return;

    const maxNet = Math.max(...this.gexLevels.map(l => Math.abs(l.netGex)), 1);

    const strikes = this.gexLevels.map(l => l.strike).sort((a, b) => a - b);

    for (const level of this.gexLevels) {
      const py = this._priceToY(level.strike);
      if (py < s.bottom || py > s.top) continue;
      const { y: barY, h: barH } = this._gexBarBounds(level.strike, strikes);

      const color = COLORS.netGex;
      const w = (Math.abs(level.netGex) / maxNet) * s.netGex.width * 0.9;

      this.groups.netGexBars.add(
        this._makePlane(s.netGex.left + 2, barY, w, barH, color, 0.85)
      );
    }
  }

  _gexBarBounds(strike, sortedStrikes) {
    const idx = sortedStrikes.indexOf(strike);
    const y = this._priceToY(strike);
    let top, bottom;
    if (sortedStrikes.length < 2) return { y, h: 4 };
    if (idx <= 0) {
      const nextY = this._priceToY(sortedStrikes[1]);
      const halfGap = Math.abs(y - nextY) / 2;
      top = y + halfGap;
      bottom = y - halfGap;
    } else if (idx >= sortedStrikes.length - 1) {
      const prevY = this._priceToY(sortedStrikes[idx - 1]);
      const halfGap = Math.abs(y - prevY) / 2;
      top = y + halfGap;
      bottom = y - halfGap;
    } else {
      const prevY = this._priceToY(sortedStrikes[idx - 1]);
      const nextY = this._priceToY(sortedStrikes[idx + 1]);
      top = (y + prevY) / 2;
      bottom = (y + nextY) / 2;
      if (top < bottom) [top, bottom] = [bottom, top];
    }
    const fullH = Math.abs(top - bottom);
    const inset = Math.min(0.5, fullH * 0.1);
    const h = Math.max(1, fullH - inset * 2);
    return { y: bottom + inset, h };
  }

  _buildSeparators() {
    const s = this._sectionBounds();
    this.groups.overlays.add(
      this._makeLine(
        [[s.axis.right, 0], [s.axis.right, this.height]],
        COLORS.separator, 0.6
      )
    );
    this.groups.overlays.add(
      this._makeLine(
        [[s.netGex.left, 0], [s.netGex.left, this.height]],
        COLORS.separator, 0.6
      )
    );
  }

  _buildPriceLine() {
    if (!this.spotPrice) return;
    const y = this._priceToY(this.spotPrice);
    const dashLen = 6;
    const gapLen = 4;
    const pts = [];
    for (let x = LAYOUT.marginLeft; x < this.width; x += dashLen + gapLen) {
      pts.push([x, y], [Math.min(x + dashLen, this.width), y]);
    }
    for (let i = 0; i < pts.length - 1; i += 2) {
      this.groups.overlays.add(
        this._makeLine([pts[i], pts[i + 1]], COLORS.priceLine, 0.8)
      );
    }
  }

  _updateLabels() {
    const overlay = document.getElementById('labels-overlay');
    overlay.innerHTML = '';
    const s = this._sectionBounds();

    // Price axis labels
    const range = this.viewPriceMax - this.viewPriceMin;
    const step = this._niceStep(range, 10);
    const startP = Math.ceil(this.viewPriceMin / step) * step;

    for (let p = startP; p <= this.viewPriceMax; p += step) {
      const y = this.height - this._priceToY(p);
      const lbl = document.createElement('div');
      lbl.className = 'price-label';
      lbl.style.top = y - 6 + 'px';
      lbl.style.left = s.axis.left + 4 + 'px';
      lbl.textContent = p.toFixed(p >= 1000 ? 0 : 2);
      overlay.appendChild(lbl);
    }

    // Current price tag
    if (this.spotPrice) {
      const y = this.height - this._priceToY(this.spotPrice);
      const tag = document.createElement('div');
      tag.className = 'current-price-tag';
      tag.style.top = y - 8 + 'px';
      tag.style.left = s.axis.left + 2 + 'px';
      tag.textContent = this.spotPrice.toFixed(2);
      overlay.appendChild(tag);
    }

    // Date labels
    const visCount = this.viewEndIdx - this.viewStartIdx;
    const labelEvery = Math.max(1, Math.floor(visCount / 10));
    const labelStart = Math.max(0, Math.floor(this.viewStartIdx));
    const labelEnd = Math.min(this.priceData.length, Math.ceil(this.viewEndIdx));
    for (let i = labelStart; i < labelEnd; i += labelEvery) {
      const c = this.priceData[i];
      if (!c) continue;
      const x = this._idxToX(i + 0.5);
      const lbl = document.createElement('div');
      lbl.className = 'date-label';
      lbl.style.left = x + 'px';
      const d = c.date;
      lbl.textContent = `${d.getMonth() + 1}/${d.getDate()}`;
      overlay.appendChild(lbl);
    }

    // Section headers
    const gexLabel = document.createElement('div');
    gexLabel.className = 'section-label';
    gexLabel.style.left = s.gex.left + 8 + 'px';
    gexLabel.textContent = 'CALL / PUT GEX';
    overlay.appendChild(gexLabel);

    const netLabel = document.createElement('div');
    netLabel.className = 'section-label';
    netLabel.style.left = s.netGex.left + 4 + 'px';
    netLabel.textContent = 'NET GEX';
    overlay.appendChild(netLabel);

    // GEX x-axis scale
    if (this.gexLevels.length > 0) {
      this._addGexScale(overlay, s);
      this._addNetGexScale(overlay, s);
    } else {
      // Show loading placeholders
      for (const [sec, text] of [[s.gex, 'Loading GEX...'], [s.netGex, 'Loading...']]) {
        const lbl = document.createElement('div');
        lbl.className = 'gex-loading-label';
        lbl.style.left = sec.left + sec.width / 2 + 'px';
        lbl.style.top = '50%';
        lbl.textContent = text;
        overlay.appendChild(lbl);
      }
    }
  }

  _addGexScale(overlay, s) {
    const maxCallGex = Math.max(...this.gexLevels.map(l => Math.abs(l.callGex)), 1);
    const maxPutGex = Math.max(...this.gexLevels.map(l => Math.abs(l.putGex)), 1);
    const maxGex = Math.max(maxCallGex, maxPutGex);
    const halfW = s.gex.width / 2;
    const centerX = s.gex.left + halfW;
    const ticks = 3;
    const scaleStep = this._niceStep(maxGex, ticks);

    // "0" label at center
    const zeroLbl = document.createElement('div');
    zeroLbl.className = 'gex-scale-label';
    zeroLbl.style.left = centerX + 'px';
    zeroLbl.textContent = '0';
    overlay.appendChild(zeroLbl);

    for (let v = scaleStep; v <= maxGex * 1.05; v += scaleStep) {
      const frac = v / maxGex;
      if (frac > 1.05) break;

      // Call side (right of center)
      const rx = centerX + frac * halfW;
      if (rx < s.gex.right - 5) {
        const rl = document.createElement('div');
        rl.className = 'gex-scale-label';
        rl.style.left = rx + 'px';
        rl.style.color = '#4caf50';
        rl.textContent = this._fmtGex(v);
        overlay.appendChild(rl);
      }

      // Put side (left of center)
      const lx = centerX - frac * halfW;
      if (lx > s.gex.left + 5) {
        const ll = document.createElement('div');
        ll.className = 'gex-scale-label';
        ll.style.left = lx + 'px';
        ll.style.color = '#f44336';
        ll.textContent = this._fmtGex(v);
        overlay.appendChild(ll);
      }
    }
  }

  _addNetGexScale(overlay, s) {
    const maxNet = Math.max(...this.gexLevels.map(l => Math.abs(l.netGex)), 1);
    const ticks = 2;
    const scaleStep = this._niceStep(maxNet, ticks);
    const usableW = s.netGex.width * 0.9;

    // "0" label at left edge
    const zLbl = document.createElement('div');
    zLbl.className = 'gex-scale-label';
    zLbl.style.left = s.netGex.left + 2 + 'px';
    zLbl.style.transform = 'none';
    zLbl.textContent = '0';
    overlay.appendChild(zLbl);

    for (let v = scaleStep; v <= maxNet * 1.05; v += scaleStep) {
      const frac = v / maxNet;
      if (frac > 1.05) break;
      const x = s.netGex.left + 2 + frac * usableW;
      if (x < s.netGex.right - 10) {
        const lbl = document.createElement('div');
        lbl.className = 'gex-scale-label';
        lbl.style.left = x + 'px';
        lbl.textContent = this._fmtGex(v);
        overlay.appendChild(lbl);
      }
    }
  }

  _niceStep(range, targetTicks) {
    const rough = range / targetTicks;
    const mag = Math.pow(10, Math.floor(Math.log10(rough)));
    const frac = rough / mag;
    let nice;
    if (frac <= 1.5) nice = 1;
    else if (frac <= 3.5) nice = 2;
    else if (frac <= 7.5) nice = 5;
    else nice = 10;
    return nice * mag;
  }

  _setupInteraction() {
    const el = this.container;
    const chH = document.getElementById('crosshair-h');
    const chV = document.getElementById('crosshair-v');
    const tooltip = document.getElementById('tooltip');

    this._axisDrag = { active: false, startY: 0, startPriceMin: 0, startPriceMax: 0, anchorFrac: 0 };
    this._chartDrag = { active: false, startX: 0, startY: 0, startViewStart: 0, startViewEnd: 0, startPriceMin: 0, startPriceMax: 0 };
    this._xAxisDrag = { active: false, startX: 0, startViewStart: 0, startViewEnd: 0, anchorFrac: 0 };
    this._manualYScale = false;

    el.addEventListener('mousedown', (e) => {
      const rect = el.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const s = this._sectionBounds();
      const inXAxis = my > (this.height - LAYOUT.marginBottom) && mx >= s.candle.left && mx <= s.candle.right;

      if (inXAxis) {
        e.preventDefault();
        this._xAxisDrag.active = true;
        this._xAxisDrag.startX = e.clientX;
        this._xAxisDrag.startViewStart = this.viewStartIdx;
        this._xAxisDrag.startViewEnd = this.viewEndIdx;
        this._xAxisDrag.anchorFrac = (mx - s.candle.left) / s.candle.width;
        el.style.cursor = 'ew-resize';
      } else if (mx >= s.axis.left && mx <= s.axis.right) {
        e.preventDefault();
        this._axisDrag.active = true;
        this._axisDrag.startY = e.clientY;
        this._axisDrag.startPriceMin = this.viewPriceMin;
        this._axisDrag.startPriceMax = this.viewPriceMax;
        this._axisDrag.anchorFrac = 1 - (my / this.height);
        this._manualYScale = true;
        el.style.cursor = 'ns-resize';
      } else if (mx >= s.candle.left && mx <= s.candle.right) {
        e.preventDefault();
        this._chartDrag.active = true;
        this._chartDrag.startX = e.clientX;
        this._chartDrag.startY = e.clientY;
        this._chartDrag.startViewStart = this.viewStartIdx;
        this._chartDrag.startViewEnd = this.viewEndIdx;
        this._chartDrag.startPriceMin = this.viewPriceMin;
        this._chartDrag.startPriceMax = this.viewPriceMax;
        this._manualYScale = true;
        el.style.cursor = 'grabbing';
        tooltip.style.display = 'none';
      }
    });

    window.addEventListener('mousemove', (e) => {
      if (this._axisDrag.active) {
        const dy = e.clientY - this._axisDrag.startY;
        const s = this._sectionBounds();
        const origRange = this._axisDrag.startPriceMax - this._axisDrag.startPriceMin;
        const zoomFactor = Math.pow(2, dy / (s.chartH * 0.5));
        let newRange = Math.max(1, origRange * zoomFactor);

        const anchorPrice = this._axisDrag.startPriceMin + this._axisDrag.anchorFrac * origRange;
        this.viewPriceMin = anchorPrice - this._axisDrag.anchorFrac * newRange;
        this.viewPriceMax = anchorPrice + (1 - this._axisDrag.anchorFrac) * newRange;

        this.rebuild();
        return;
      }

      if (this._chartDrag.active) {
        const s = this._sectionBounds();
        const dx = e.clientX - this._chartDrag.startX;
        const dy = e.clientY - this._chartDrag.startY;
        const visCount = this._chartDrag.startViewEnd - this._chartDrag.startViewStart;

        const idxShift = -(dx / s.candle.width) * visCount;
        this.viewStartIdx = this._chartDrag.startViewStart + idxShift;
        this.viewEndIdx = this._chartDrag.startViewEnd + idxShift;

        const priceRange = this._chartDrag.startPriceMax - this._chartDrag.startPriceMin;
        const priceShift = (dy / s.chartH) * priceRange;
        this.viewPriceMin = this._chartDrag.startPriceMin + priceShift;
        this.viewPriceMax = this._chartDrag.startPriceMax + priceShift;

        this.rebuild();
        return;
      }

      if (this._xAxisDrag.active) {
        const s = this._sectionBounds();
        const dx = e.clientX - this._xAxisDrag.startX;
        const origCount = this._xAxisDrag.startViewEnd - this._xAxisDrag.startViewStart;
        const anchorIdx = this._xAxisDrag.startViewStart + this._xAxisDrag.anchorFrac * origCount;
        const zoomFactor = Math.pow(2, dx / (s.candle.width * 0.5));
        const newCount = Math.max(5, origCount * zoomFactor);

        this.viewStartIdx = anchorIdx - this._xAxisDrag.anchorFrac * newCount;
        this.viewEndIdx = anchorIdx + (1 - this._xAxisDrag.anchorFrac) * newCount;

        this.rebuild();
        return;
      }

      const rect = el.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      if (mx >= 0 && mx <= this.width && my >= 0 && my <= this.height) {
        const s = this._sectionBounds();
        const inXAxis = my > (this.height - LAYOUT.marginBottom) && mx >= s.candle.left && mx <= s.candle.right;
        if (inXAxis) {
          el.style.cursor = 'ew-resize';
        } else if (mx >= s.axis.left && mx <= s.axis.right) {
          el.style.cursor = 'ns-resize';
        } else if (mx >= s.candle.left && mx <= s.candle.right) {
          el.style.cursor = 'grab';
        } else {
          el.style.cursor = '';
        }

        chH.style.display = 'block';
        chV.style.display = 'block';
        chH.style.top = my + 'px';
        chV.style.left = mx + 'px';

        const price = this._yToPrice(this.height - my);

        if (mx >= s.candle.left && mx <= s.candle.right) {
          const visCount = this.viewEndIdx - this.viewStartIdx;
          const idx = Math.floor(
            this.viewStartIdx + ((mx - s.candle.left) / s.candle.width) * visCount
          );
          const c = this.priceData[idx];
          if (c) {
            tooltip.style.display = 'block';
            tooltip.style.left = (mx + 12) + 'px';
            tooltip.style.top = (my - 10) + 'px';
            const d = c.date;
            let html =
              `<div>${d.toLocaleDateString()}</div>` +
              `<div>O: ${c.open.toFixed(2)}&nbsp; H: ${c.high.toFixed(2)}</div>` +
              `<div>L: ${c.low.toFixed(2)}&nbsp; C: ${c.close.toFixed(2)}</div>` +
              `<div>Vol: ${(c.volume / 1e6).toFixed(1)}M</div>`;
            const nearest = this._nearestGexLevel(price);
            if (nearest) {
              html +=
                `<div style="border-top:1px solid #30363d;margin-top:4px;padding-top:4px">Strike: ${nearest.strike}</div>` +
                `<div style="color:#4caf50">Call GEX: ${this._fmtGex(nearest.callGex)}</div>` +
                `<div style="color:#f44336">Put GEX: ${this._fmtGex(nearest.putGex)}</div>` +
                `<div style="color:#00bcd4">Net GEX: ${this._fmtGex(nearest.netGex)}</div>`;
            }
            tooltip.innerHTML = html;
          }
        } else if (mx >= s.gex.left && mx <= s.netGex.right) {
          const nearest = this._nearestGexLevel(price);
          if (nearest) {
            tooltip.style.display = 'block';
            tooltip.style.left = (mx + 12) + 'px';
            tooltip.style.top = (my - 10) + 'px';
            tooltip.innerHTML =
              `<div>Strike: ${nearest.strike}</div>` +
              `<div style="color:#4caf50">Call GEX: ${this._fmtGex(nearest.callGex)}</div>` +
              `<div style="color:#f44336">Put GEX: ${this._fmtGex(nearest.putGex)}</div>` +
              `<div style="color:#00bcd4">Net GEX: ${this._fmtGex(nearest.netGex)}</div>`;
          }
        } else {
          tooltip.style.display = 'none';
        }
      } else {
        chH.style.display = 'none';
        chV.style.display = 'none';
        tooltip.style.display = 'none';
        if (!this._axisDrag.active && !this._chartDrag.active && !this._xAxisDrag.active) el.style.cursor = '';
      }
    });

    window.addEventListener('mouseup', () => {
      if (this._axisDrag.active) {
        this._axisDrag.active = false;
        el.style.cursor = '';
      }
      if (this._chartDrag.active) {
        this._chartDrag.active = false;
        el.style.cursor = '';
      }
      if (this._xAxisDrag.active) {
        this._xAxisDrag.active = false;
        el.style.cursor = '';
      }
    });

    el.addEventListener('dblclick', (e) => {
      const rect = el.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const s = this._sectionBounds();
      if (mx >= s.axis.left && mx <= s.axis.right) {
        this._manualYScale = false;
        this._autoFitY();
        this.rebuild();
      } else if (mx >= s.candle.left && mx <= s.candle.right) {
        this._manualYScale = false;
        this.viewStartIdx = 0;
        this.viewEndIdx = this.priceData.length;
        this._autoFitY();
        this.rebuild();
      }
    });

    el.addEventListener('mouseleave', () => {
      if (!this._axisDrag.active && !this._chartDrag.active && !this._xAxisDrag.active) {
        chH.style.display = 'none';
        chV.style.display = 'none';
        tooltip.style.display = 'none';
      }
    });

    el.addEventListener('wheel', (e) => {
      const rect = el.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const s = this._sectionBounds();
      const inCandle = mx >= s.candle.left && mx <= s.candle.right && my <= (this.height - LAYOUT.marginBottom);
      if (!inCandle) return;

      e.preventDefault();
      const zoomFactor = Math.pow(1.03, e.deltaY > 0 ? 1 : -1);

      const anchorFrac = (mx - s.candle.left) / s.candle.width;
      const visCount = this.viewEndIdx - this.viewStartIdx;
      const anchorIdx = this.viewStartIdx + anchorFrac * visCount;
      const newCount = Math.max(5, visCount * zoomFactor);
      this.viewStartIdx = anchorIdx - anchorFrac * newCount;
      this.viewEndIdx = anchorIdx + (1 - anchorFrac) * newCount;

      const priceFrac = 1 - (my - (this.height - s.top)) / s.chartH;
      const priceRange = this.viewPriceMax - this.viewPriceMin;
      const anchorPrice = this.viewPriceMin + priceFrac * priceRange;
      const newRange = Math.max(0.01, priceRange * zoomFactor);
      this.viewPriceMin = anchorPrice - priceFrac * newRange;
      this.viewPriceMax = anchorPrice + (1 - priceFrac) * newRange;
      this._manualYScale = true;

      this.rebuild();
    }, { passive: false });
  }

  _nearestGexLevel(price) {
    let best = null;
    let bestDist = Infinity;
    for (const l of this.gexLevels) {
      const d = Math.abs(l.strike - price);
      if (d < bestDist) { bestDist = d; best = l; }
    }
    return best;
  }

  _fmtGex(val) {
    const abs = Math.abs(val);
    const sign = val < 0 ? '-' : '';
    if (abs >= 1e9) return sign + (abs / 1e9).toFixed(2) + 'B';
    if (abs >= 1e6) return sign + (abs / 1e6).toFixed(2) + 'M';
    if (abs >= 1e3) return sign + (abs / 1e3).toFixed(1) + 'K';
    return sign + abs.toFixed(0);
  }

  _render() {
    this.renderer.render(this.scene, this.camera);
  }

  _animate() {
    requestAnimationFrame(() => this._animate());
    this._render();
  }

  _onResize() {
    this.width = this.container.clientWidth;
    this.height = this.container.clientHeight;
    this.camera.right = this.width;
    this.camera.top = this.height;
    this.camera.updateProjectionMatrix();
    this.renderer.setSize(this.width, this.height);
    if (this.priceData.length) this.rebuild();
  }
}

// --- App logic ---

const FREQ_MAP = {
  '5m':  { frequencyType: 'minute',  frequency: '5' },
  '15m': { frequencyType: 'minute',  frequency: '15' },
  '30m': { frequencyType: 'minute',  frequency: '30' },
  '1D':  { frequencyType: 'daily',   frequency: '1' },
  '1W':  { frequencyType: 'weekly',  frequency: '1' },
  '1M':  { frequencyType: 'monthly', frequency: '1' },
};

const RANGE_MAP = {
  '5D':  { periodType: 'day',   period: '5' },
  '1M':  { periodType: 'month', period: '1' },
  '3M':  { periodType: 'month', period: '3' },
  '6M':  { periodType: 'month', period: '6' },
  'YTD': { periodType: 'ytd',   period: '1' },
  '1Y':  { periodType: 'year',  period: '1' },
  '2Y':  { periodType: 'year',  period: '2' },
  '5Y':  { periodType: 'year',  period: '5' },
  '10Y': { periodType: 'year',  period: '10' },
  '20Y': { periodType: 'year',  period: '20' },
};

let currentSymbol = 'AAPL';
let allExpirations = [];
let selectedExpirations = new Set();

function ensureChart() {
  if (!window._chart) {
    window._chart = new GEXChart(document.getElementById('chart-wrap'));
  }
  return window._chart;
}

async function checkAuth() {
  const res = await fetch('/auth/status');
  const data = await res.json();
  return data.authenticated;
}

function getPriceParams() {
  const freqVal = document.getElementById('freq-select').value;
  const rangeVal = document.getElementById('range-select').value;
  const freq = FREQ_MAP[freqVal] || FREQ_MAP['1D'];
  const range = RANGE_MAP[rangeVal] || RANGE_MAP['1Y'];

  // Schwab API constraints: minute frequencies only support periodType=day (max 10)
  if (freq.frequencyType === 'minute') {
    const dayPeriods = { '5D': 5, '1M': 10, '3M': 10, '6M': 10, 'YTD': 10, '1Y': 10, '2Y': 10, '5Y': 10, '10Y': 10, '20Y': 10 };
    return { ...freq, periodType: 'day', period: String(dayPeriods[rangeVal] || 10) };
  }
  // monthly frequency only supports periodType=year
  if (freq.frequencyType === 'monthly' && range.periodType !== 'year') {
    return { ...freq, periodType: 'year', period: '1' };
  }
  return { ...freq, ...range };
}

async function loadPrice(symbol) {
  const loading = document.getElementById('loading');
  const chart = ensureChart();
  const params = getPriceParams();
  const qs = new URLSearchParams(params).toString();

  loading.style.display = 'block';
  loading.textContent = `Loading ${symbol} price...`;

  try {
    const res = await fetch(`/api/price/${encodeURIComponent(symbol)}?${qs}`);
    if (res.status === 401) { window.location.href = '/auth/login'; return; }
    if (!res.ok) throw new Error('Price API error');
    const priceData = await res.json();
    loading.style.display = 'none';
    chart.loadPriceData(priceData);
  } catch (err) {
    loading.textContent = 'Failed to load price data.';
    console.error('Price load error:', err);
  }
}

function applyGexHeader(gexData) {
  const underlying = gexData.underlying || {};
  const price = gexData.underlyingPrice || underlying.last || 0;
  const change = underlying.change || 0;
  const pctChange = underlying.percentChange || 0;

  document.getElementById('hdr-price').textContent = '$' + price.toFixed(2);
  const changeEl = document.getElementById('hdr-change');
  const sign = change >= 0 ? '+' : '';
  changeEl.textContent = `${sign}${change.toFixed(2)} (${sign}${pctChange.toFixed(2)}%)`;
  changeEl.className = 'change ' + (change >= 0 ? 'up' : 'down');
}

function updateExpirationsFromData(dates) {
  allExpirations = dates;
  const cutoff = new Date();
  cutoff.setDate(cutoff.getDate() + 60);
  const cutoffStr = cutoff.toISOString().slice(0, 10);
  const within60 = allExpirations.filter(d => d <= cutoffStr);
  selectedExpirations = new Set(within60.length > 0 ? within60 : allExpirations);
  updateFilterButton();
}

async function loadGEX(symbol, { useFilter = false } = {}) {
  const chart = ensureChart();
  try {
    let url = `/api/gex/${encodeURIComponent(symbol)}`;
    if (useFilter && selectedExpirations.size > 0 && selectedExpirations.size < allExpirations.length) {
      url += `?expirations=${[...selectedExpirations].join(',')}`;
    }
    const res = await fetch(url);
    if (res.status === 401) return;
    if (!res.ok) throw new Error('GEX API error');

    if (useFilter) {
      const gexData = await res.json();
      applyGexHeader(gexData);
      if (gexData.expirationDates) {
        allExpirations = gexData.expirationDates;
        updateFilterButton();
      }
      chart.loadGEXData(gexData);
      return;
    }

    const reader = res.body.getReader();
    const decoder = new TextDecoder();
    let buffer = '';
    let firstChunkApplied = false;

    while (true) {
      const { value, done: streamDone } = await reader.read();
      if (streamDone) break;
      buffer += decoder.decode(value, { stream: true });

      let newlineIdx;
      while ((newlineIdx = buffer.indexOf('\n')) !== -1) {
        const line = buffer.slice(0, newlineIdx).trim();
        buffer = buffer.slice(newlineIdx + 1);
        if (!line) continue;

        const chunk = JSON.parse(line);
        if (chunk.done) break;

        if (!firstChunkApplied && chunk.gexLevels) {
          applyGexHeader(chunk);
          chart.loadGEXData(chunk);
          firstChunkApplied = true;
        }

        if (chunk.expirationDates) {
          updateExpirationsFromData(chunk.expirationDates);
        }
      }
    }
  } catch (err) {
    console.error('GEX load error:', err);
  }
}

function updateFilterButton() {
  const btn = document.getElementById('exp-filter-btn');
  const count = selectedExpirations.size;
  const total = allExpirations.length;
  if (total === 0) {
    btn.innerHTML = 'Expirations';
  } else if (count === total) {
    btn.innerHTML = `Expirations <span class="badge">${total}</span>`;
  } else {
    btn.innerHTML = `Expirations <span class="badge">${count}/${total}</span>`;
  }
}

function openExpDialog() {
  const list = document.getElementById('exp-dialog-list');
  list.innerHTML = '';
  for (const exp of allExpirations) {
    const label = document.createElement('label');
    const cb = document.createElement('input');
    cb.type = 'checkbox';
    cb.value = exp;
    cb.checked = selectedExpirations.has(exp);
    label.appendChild(cb);
    label.appendChild(document.createTextNode(exp));
    list.appendChild(label);
  }
  document.getElementById('exp-dialog-backdrop').classList.add('open');
}

function closeExpDialog() {
  document.getElementById('exp-dialog-backdrop').classList.remove('open');
}

function applyExpFilter() {
  const checkboxes = document.querySelectorAll('#exp-dialog-list input[type="checkbox"]');
  selectedExpirations = new Set();
  checkboxes.forEach(cb => { if (cb.checked) selectedExpirations.add(cb.value); });
  updateFilterButton();
  closeExpDialog();
  if (currentSymbol) loadGEX(currentSymbol, { useFilter: true });
}

async function loadSymbol(symbol) {
  currentSymbol = symbol;
  const chart = ensureChart();

  allExpirations = [];
  selectedExpirations = new Set();
  updateFilterButton();

  document.getElementById('hdr-symbol').textContent = symbol;
  document.getElementById('hdr-price').textContent = '--';
  document.getElementById('hdr-change').textContent = '--';
  document.getElementById('hdr-change').className = 'change';
  chart.clearGEX();

  loadPrice(symbol);
  loadGEX(symbol);
}

async function init() {
  const authed = await checkAuth();
  if (!authed) {
    document.getElementById('login-screen').style.display = 'flex';
    document.getElementById('app').classList.remove('active');
    return;
  }

  document.getElementById('login-screen').style.display = 'none';
  document.getElementById('app').classList.add('active');

  const input = document.getElementById('symbol-input');
  const btn = document.getElementById('load-btn');
  const freqSel = document.getElementById('freq-select');
  const rangeSel = document.getElementById('range-select');

  const go = () => {
    const sym = (input.value.trim() || 'AAPL').toUpperCase();
    input.value = sym;
    loadSymbol(sym);
  };

  btn.addEventListener('click', go);
  input.addEventListener('keydown', (e) => { if (e.key === 'Enter') go(); });

  freqSel.addEventListener('change', () => {
    if (currentSymbol) loadPrice(currentSymbol);
  });
  rangeSel.addEventListener('change', () => {
    if (currentSymbol) loadPrice(currentSymbol);
  });

  document.getElementById('exp-filter-btn').addEventListener('click', openExpDialog);
  document.getElementById('exp-dialog-close').addEventListener('click', closeExpDialog);
  document.getElementById('exp-dialog-apply').addEventListener('click', applyExpFilter);
  document.getElementById('exp-select-all').addEventListener('click', () => {
    document.querySelectorAll('#exp-dialog-list input[type="checkbox"]').forEach(cb => cb.checked = true);
  });
  document.getElementById('exp-select-none').addEventListener('click', () => {
    document.querySelectorAll('#exp-dialog-list input[type="checkbox"]').forEach(cb => cb.checked = false);
  });
  document.getElementById('exp-dialog-backdrop').addEventListener('click', (e) => {
    if (e.target === e.currentTarget) closeExpDialog();
  });

  input.value = 'AAPL';
  go();
}

init();
</script>

</body>
</html>
